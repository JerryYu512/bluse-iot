// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: enums/e_network.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_enums_2fe_5fnetwork_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_enums_2fe_5fnetwork_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_enums_2fe_5fnetwork_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_enums_2fe_5fnetwork_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_enums_2fe_5fnetwork_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace biot {

enum NetLanType : int {
  LAN_WORK_10M_HALF = 0,
  LAN_WORK_10M_FULL = 1,
  LAN_WORK_100M_HALF = 2,
  LAN_WORK_100M_FULL = 3,
  LAN_WORK_AUTO = 4,
  LAN_WORK_1G_FULL = 5,
  NetLanType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NetLanType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NetLanType_IsValid(int value);
constexpr NetLanType NetLanType_MIN = LAN_WORK_10M_HALF;
constexpr NetLanType NetLanType_MAX = LAN_WORK_1G_FULL;
constexpr int NetLanType_ARRAYSIZE = NetLanType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NetLanType_descriptor();
template<typename T>
inline const std::string& NetLanType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetLanType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetLanType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NetLanType_descriptor(), enum_t_value);
}
inline bool NetLanType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetLanType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NetLanType>(
    NetLanType_descriptor(), name, value);
}
enum NetIfRate : int {
  NET_IF_RATE_100M = 0,
  NET_IF_RATE_1000M = 1,
  NetIfRate_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NetIfRate_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NetIfRate_IsValid(int value);
constexpr NetIfRate NetIfRate_MIN = NET_IF_RATE_100M;
constexpr NetIfRate NetIfRate_MAX = NET_IF_RATE_1000M;
constexpr int NetIfRate_ARRAYSIZE = NetIfRate_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NetIfRate_descriptor();
template<typename T>
inline const std::string& NetIfRate_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetIfRate>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetIfRate_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NetIfRate_descriptor(), enum_t_value);
}
inline bool NetIfRate_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetIfRate* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NetIfRate>(
    NetIfRate_descriptor(), name, value);
}
enum NetCfgType : int {
  NET_CFG_MANUAL = 0,
  NET_CFG_AUTO = 1,
  NetCfgType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NetCfgType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NetCfgType_IsValid(int value);
constexpr NetCfgType NetCfgType_MIN = NET_CFG_MANUAL;
constexpr NetCfgType NetCfgType_MAX = NET_CFG_AUTO;
constexpr int NetCfgType_ARRAYSIZE = NetCfgType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NetCfgType_descriptor();
template<typename T>
inline const std::string& NetCfgType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NetCfgType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NetCfgType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NetCfgType_descriptor(), enum_t_value);
}
inline bool NetCfgType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NetCfgType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NetCfgType>(
    NetCfgType_descriptor(), name, value);
}
enum WireLessIfMode : int {
  WIRELESS_IF_AUTO = 0,
  WIRELESS_IF_LAN = 1,
  WireLessIfMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WireLessIfMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WireLessIfMode_IsValid(int value);
constexpr WireLessIfMode WireLessIfMode_MIN = WIRELESS_IF_AUTO;
constexpr WireLessIfMode WireLessIfMode_MAX = WIRELESS_IF_LAN;
constexpr int WireLessIfMode_ARRAYSIZE = WireLessIfMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WireLessIfMode_descriptor();
template<typename T>
inline const std::string& WireLessIfMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WireLessIfMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WireLessIfMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WireLessIfMode_descriptor(), enum_t_value);
}
inline bool WireLessIfMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WireLessIfMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WireLessIfMode>(
    WireLessIfMode_descriptor(), name, value);
}
enum WireLessWorkMode : int {
  WIRELESS_WORK_MANAGED = 0,
  WIRELESS_WORK_AD_HOC = 1,
  WireLessWorkMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WireLessWorkMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WireLessWorkMode_IsValid(int value);
constexpr WireLessWorkMode WireLessWorkMode_MIN = WIRELESS_WORK_MANAGED;
constexpr WireLessWorkMode WireLessWorkMode_MAX = WIRELESS_WORK_AD_HOC;
constexpr int WireLessWorkMode_ARRAYSIZE = WireLessWorkMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WireLessWorkMode_descriptor();
template<typename T>
inline const std::string& WireLessWorkMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WireLessWorkMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WireLessWorkMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WireLessWorkMode_descriptor(), enum_t_value);
}
inline bool WireLessWorkMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WireLessWorkMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WireLessWorkMode>(
    WireLessWorkMode_descriptor(), name, value);
}
enum WireLessSecMode : int {
  WIRELESS_SEC_NONE = 0,
  WIRELESS_SEC_WEP = 1,
  WIRELESS_SEC_WPA_PSK = 2,
  WIRELESS_SEC_WPA_ENTERPRISE = 3,
  WIRELESS_SEC_WPA2_PSK = 4,
  WireLessSecMode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WireLessSecMode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WireLessSecMode_IsValid(int value);
constexpr WireLessSecMode WireLessSecMode_MIN = WIRELESS_SEC_NONE;
constexpr WireLessSecMode WireLessSecMode_MAX = WIRELESS_SEC_WPA2_PSK;
constexpr int WireLessSecMode_ARRAYSIZE = WireLessSecMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WireLessSecMode_descriptor();
template<typename T>
inline const std::string& WireLessSecMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WireLessSecMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WireLessSecMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WireLessSecMode_descriptor(), enum_t_value);
}
inline bool WireLessSecMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WireLessSecMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WireLessSecMode>(
    WireLessSecMode_descriptor(), name, value);
}
enum WireLessWepAuthType : int {
  WIRELESS_WEPAUTH_OPEN = 0,
  WIRELESS_WEPAUTH_SHARE = 1,
  WireLessWepAuthType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WireLessWepAuthType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WireLessWepAuthType_IsValid(int value);
constexpr WireLessWepAuthType WireLessWepAuthType_MIN = WIRELESS_WEPAUTH_OPEN;
constexpr WireLessWepAuthType WireLessWepAuthType_MAX = WIRELESS_WEPAUTH_SHARE;
constexpr int WireLessWepAuthType_ARRAYSIZE = WireLessWepAuthType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WireLessWepAuthType_descriptor();
template<typename T>
inline const std::string& WireLessWepAuthType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WireLessWepAuthType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WireLessWepAuthType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WireLessWepAuthType_descriptor(), enum_t_value);
}
inline bool WireLessWepAuthType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WireLessWepAuthType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WireLessWepAuthType>(
    WireLessWepAuthType_descriptor(), name, value);
}
enum WireLessWepKeyLen : int {
  WIRELESS_WEPKEY_LEN64 = 0,
  WIRELESS_WEPKEY_LEN128 = 1,
  WIRELESS_WEPKEY_LEN152 = 2,
  WireLessWepKeyLen_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WireLessWepKeyLen_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WireLessWepKeyLen_IsValid(int value);
constexpr WireLessWepKeyLen WireLessWepKeyLen_MIN = WIRELESS_WEPKEY_LEN64;
constexpr WireLessWepKeyLen WireLessWepKeyLen_MAX = WIRELESS_WEPKEY_LEN152;
constexpr int WireLessWepKeyLen_ARRAYSIZE = WireLessWepKeyLen_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WireLessWepKeyLen_descriptor();
template<typename T>
inline const std::string& WireLessWepKeyLen_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WireLessWepKeyLen>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WireLessWepKeyLen_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WireLessWepKeyLen_descriptor(), enum_t_value);
}
inline bool WireLessWepKeyLen_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WireLessWepKeyLen* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WireLessWepKeyLen>(
    WireLessWepKeyLen_descriptor(), name, value);
}
enum WireLessWepKeyType : int {
  WIRELESS_WEPKEY_HEX = 0,
  WIRELESS_WEPKEY_ASCII = 1,
  WireLessWepKeyType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WireLessWepKeyType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WireLessWepKeyType_IsValid(int value);
constexpr WireLessWepKeyType WireLessWepKeyType_MIN = WIRELESS_WEPKEY_HEX;
constexpr WireLessWepKeyType WireLessWepKeyType_MAX = WIRELESS_WEPKEY_ASCII;
constexpr int WireLessWepKeyType_ARRAYSIZE = WireLessWepKeyType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WireLessWepKeyType_descriptor();
template<typename T>
inline const std::string& WireLessWepKeyType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WireLessWepKeyType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WireLessWepKeyType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WireLessWepKeyType_descriptor(), enum_t_value);
}
inline bool WireLessWepKeyType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WireLessWepKeyType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WireLessWepKeyType>(
    WireLessWepKeyType_descriptor(), name, value);
}
enum WireLessWpaEncryptType : int {
  WIRELESS_WPA_ENCRYPT_AES = 0,
  WIRELESS_WPA_ENCRYPT_TKIP = 1,
  WireLessWpaEncryptType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WireLessWpaEncryptType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WireLessWpaEncryptType_IsValid(int value);
constexpr WireLessWpaEncryptType WireLessWpaEncryptType_MIN = WIRELESS_WPA_ENCRYPT_AES;
constexpr WireLessWpaEncryptType WireLessWpaEncryptType_MAX = WIRELESS_WPA_ENCRYPT_TKIP;
constexpr int WireLessWpaEncryptType_ARRAYSIZE = WireLessWpaEncryptType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* WireLessWpaEncryptType_descriptor();
template<typename T>
inline const std::string& WireLessWpaEncryptType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WireLessWpaEncryptType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WireLessWpaEncryptType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    WireLessWpaEncryptType_descriptor(), enum_t_value);
}
inline bool WireLessWpaEncryptType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WireLessWpaEncryptType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<WireLessWpaEncryptType>(
    WireLessWpaEncryptType_descriptor(), name, value);
}
enum BiotAppModuleProtocol : int {
  MODULE_PROTOC_MQTT = 0,
  MODULE_PROTOC_NNG = 1,
  MODULE_PROTOC_PROTOBUF = 2,
  BiotAppModuleProtocol_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BiotAppModuleProtocol_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BiotAppModuleProtocol_IsValid(int value);
constexpr BiotAppModuleProtocol BiotAppModuleProtocol_MIN = MODULE_PROTOC_MQTT;
constexpr BiotAppModuleProtocol BiotAppModuleProtocol_MAX = MODULE_PROTOC_PROTOBUF;
constexpr int BiotAppModuleProtocol_ARRAYSIZE = BiotAppModuleProtocol_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BiotAppModuleProtocol_descriptor();
template<typename T>
inline const std::string& BiotAppModuleProtocol_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BiotAppModuleProtocol>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BiotAppModuleProtocol_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BiotAppModuleProtocol_descriptor(), enum_t_value);
}
inline bool BiotAppModuleProtocol_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BiotAppModuleProtocol* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BiotAppModuleProtocol>(
    BiotAppModuleProtocol_descriptor(), name, value);
}
enum BiotAppModulePayload : int {
  MODULE_PAYLOAD_RAW = 0,
  MODULE_PAYLOAD_HTTP = 1,
  MODULE_PAYLOAD_JSON = 2,
  MODULE_PAYLOAD_XML = 3,
  MODULE_PAYLOAD_PROTOBUF = 4,
  BiotAppModulePayload_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BiotAppModulePayload_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BiotAppModulePayload_IsValid(int value);
constexpr BiotAppModulePayload BiotAppModulePayload_MIN = MODULE_PAYLOAD_RAW;
constexpr BiotAppModulePayload BiotAppModulePayload_MAX = MODULE_PAYLOAD_PROTOBUF;
constexpr int BiotAppModulePayload_ARRAYSIZE = BiotAppModulePayload_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BiotAppModulePayload_descriptor();
template<typename T>
inline const std::string& BiotAppModulePayload_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BiotAppModulePayload>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BiotAppModulePayload_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BiotAppModulePayload_descriptor(), enum_t_value);
}
inline bool BiotAppModulePayload_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BiotAppModulePayload* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BiotAppModulePayload>(
    BiotAppModulePayload_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace biot

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::biot::NetLanType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::biot::NetLanType>() {
  return ::biot::NetLanType_descriptor();
}
template <> struct is_proto_enum< ::biot::NetIfRate> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::biot::NetIfRate>() {
  return ::biot::NetIfRate_descriptor();
}
template <> struct is_proto_enum< ::biot::NetCfgType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::biot::NetCfgType>() {
  return ::biot::NetCfgType_descriptor();
}
template <> struct is_proto_enum< ::biot::WireLessIfMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::biot::WireLessIfMode>() {
  return ::biot::WireLessIfMode_descriptor();
}
template <> struct is_proto_enum< ::biot::WireLessWorkMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::biot::WireLessWorkMode>() {
  return ::biot::WireLessWorkMode_descriptor();
}
template <> struct is_proto_enum< ::biot::WireLessSecMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::biot::WireLessSecMode>() {
  return ::biot::WireLessSecMode_descriptor();
}
template <> struct is_proto_enum< ::biot::WireLessWepAuthType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::biot::WireLessWepAuthType>() {
  return ::biot::WireLessWepAuthType_descriptor();
}
template <> struct is_proto_enum< ::biot::WireLessWepKeyLen> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::biot::WireLessWepKeyLen>() {
  return ::biot::WireLessWepKeyLen_descriptor();
}
template <> struct is_proto_enum< ::biot::WireLessWepKeyType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::biot::WireLessWepKeyType>() {
  return ::biot::WireLessWepKeyType_descriptor();
}
template <> struct is_proto_enum< ::biot::WireLessWpaEncryptType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::biot::WireLessWpaEncryptType>() {
  return ::biot::WireLessWpaEncryptType_descriptor();
}
template <> struct is_proto_enum< ::biot::BiotAppModuleProtocol> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::biot::BiotAppModuleProtocol>() {
  return ::biot::BiotAppModuleProtocol_descriptor();
}
template <> struct is_proto_enum< ::biot::BiotAppModulePayload> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::biot::BiotAppModulePayload>() {
  return ::biot::BiotAppModulePayload_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_enums_2fe_5fnetwork_2eproto
